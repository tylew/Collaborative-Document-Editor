/**
 * CRDT Delta Consumer Test Framework
 * 
 * Reads test deltas generated by JavaScript/Yjs and validates
 * against C++ libyrs implementation.
 * 
 * Usage: ./test-deltas <test-directory>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <vector>
#include <string>
#include <algorithm>

extern "C" {
#include <libyrs.h>
}

// Test result structure
struct TestResult {
    std::string test_id;
    bool passed;
    std::string error_message;
    int deltas_applied;
    int deltas_failed;
};

// Read file into buffer
char* read_file(const char* filepath, size_t *size_out) {
    FILE *f = fopen(filepath, "rb");
    if (!f) {
        *size_out = 0;
        return NULL;
    }
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    if (size <= 0) {
        fclose(f);
        *size_out = 0;
        return NULL;
    }
    
    char *buffer = (char*)malloc(size);
    size_t read = fread(buffer, 1, size, f);
    fclose(f);
    
    if (read != (size_t)size) {
        free(buffer);
        *size_out = 0;
        return NULL;
    }
    
    *size_out = size;
    return buffer;
}

// Read expected text output
std::string read_expected(const char* test_dir) {
    char filepath[512];
    snprintf(filepath, sizeof(filepath), "%s/expected.txt", test_dir);
    
    size_t size = 0;
    char *content = read_file(filepath, &size);
    
    if (!content) {
        return "";
    }
    
    std::string result(content, size);
    free(content);
    return result;
}

// Get list of delta files in directory
std::vector<std::string> get_delta_files(const char* test_dir) {
    std::vector<std::string> deltas;
    
    DIR *dir = opendir(test_dir);
    if (!dir) return deltas;
    
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        std::string filename = entry->d_name;
        
        // Check for delta files (delta.bin or delta_NNN.bin)
        if (filename.find("delta") == 0 && filename.find(".bin") != std::string::npos) {
            char filepath[512];
            snprintf(filepath, sizeof(filepath), "%s/%s", test_dir, filename.c_str());
            deltas.push_back(filepath);
        }
    }
    
    closedir(dir);
    
    // Sort to ensure correct order (delta_001.bin, delta_002.bin, etc.)
    std::sort(deltas.begin(), deltas.end());
    
    return deltas;
}

// Hex dump for debugging
void hex_dump(const unsigned char *data, size_t len, size_t max_bytes = 20) {
    for (size_t i = 0; i < len && i < max_bytes; i++) {
        printf("%02X ", data[i]);
    }
    if (len > max_bytes) {
        printf("... (%zu more bytes)", len - max_bytes);
    }
}

// Run single test case
TestResult run_test(const char* test_dir) {
    TestResult result;
    result.test_id = std::string(test_dir);
    result.passed = false;
    result.deltas_applied = 0;
    result.deltas_failed = 0;
    
    // Extract test ID from path
    const char *last_slash = strrchr(test_dir, '/');
    if (last_slash) {
        result.test_id = std::string(last_slash + 1);
    }
    
    printf("\n[%s]\n", result.test_id.c_str());
    
    // Read expected output
    std::string expected = read_expected(test_dir);
    if (expected.empty() && errno != 0) {
        result.error_message = "Failed to read expected.txt";
        printf("  ✗ %s\n", result.error_message.c_str());
        return result;
    }
    printf("  Expected: \"%s\"\n", expected.c_str());
    
    // Get delta files
    std::vector<std::string> delta_files = get_delta_files(test_dir);
    if (delta_files.empty()) {
        result.error_message = "No delta files found";
        printf("  ✗ %s\n", result.error_message.c_str());
        return result;
    }
    printf("  Found %zu delta file(s)\n", delta_files.size());
    
    // Create YDoc with shared type matching JS
    YDoc *doc = ydoc_new();
    if (!doc) {
        result.error_message = "Failed to create YDoc";
        printf("  ✗ %s\n", result.error_message.c_str());
        return result;
    }
    
    Branch *text = ytext(doc, "document");  // Must match JS: getText('document')
    if (!text) {
        result.error_message = "Failed to create YText";
        printf("  ✗ %s\n", result.error_message.c_str());
        ydoc_destroy(doc);
        return result;
    }
    
    // Apply each delta in sequence
    for (size_t i = 0; i < delta_files.size(); i++) {
        const char *delta_file = delta_files[i].c_str();
        
        printf("\n  --- Delta %zu ---\n", i + 1);
        
        // Read delta
        size_t delta_len = 0;
        char *delta_data = read_file(delta_file, &delta_len);
        
        if (!delta_data) {
            char msg[256];
            snprintf(msg, sizeof(msg), "Failed to read %s", delta_file);
            result.error_message = msg;
            printf("  ✗ %s\n", result.error_message.c_str());
            result.deltas_failed++;
            ydoc_destroy(doc);
            return result;
        }
        
        printf("  File: %s\n", delta_file);
        printf("  Size: %zu bytes\n", delta_len);
        printf("  Hex:  ");
        hex_dump((unsigned char*)delta_data, delta_len, 32);
        printf("\n");
        
        // Show document state BEFORE applying delta
        YTransaction *pre_txn = ydoc_read_transaction(doc);
        const char *pre_content = ytext_string(text, pre_txn);
        std::string pre_str = pre_content ? std::string(pre_content) : "";
        printf("  Before: \"%s\" (length: %zu)\n", pre_str.c_str(), pre_str.length());
        if (pre_content) {
            ystring_destroy((char*)pre_content);
        }
        ytransaction_commit(pre_txn);
        
        // Apply delta to document
        YTransaction *txn = ydoc_write_transaction(doc, 0, NULL);
        uint8_t err = ytransaction_apply(txn, delta_data, (uint32_t)delta_len);
        ytransaction_commit(txn);
        
        free(delta_data);
        
        if (err != 0) {
            // Try V2 format
            printf("  V1 failed (error %d), trying V2...\n", err);
            delta_data = read_file(delta_file, &delta_len);
            YTransaction *txn2 = ydoc_write_transaction(doc, 0, NULL);
            err = ytransaction_apply_v2(txn2, delta_data, (uint32_t)delta_len);
            ytransaction_commit(txn2);
            free(delta_data);
            
            if (err != 0) {
                char msg[256];
                snprintf(msg, sizeof(msg), "Delta %zu application failed (error: %d)", i + 1, err);
                result.error_message = msg;
                printf("  ✗ %s\n", result.error_message.c_str());
                result.deltas_failed++;
                ydoc_destroy(doc);
                return result;
            } else {
                printf("  ✓ Applied successfully (V2 format)\n");
            }
        } else {
            printf("  ✓ Applied successfully (V1 format)\n");
        }
        
        // Show document state AFTER applying delta
        YTransaction *post_txn = ydoc_read_transaction(doc);
        const char *post_content = ytext_string(text, post_txn);
        std::string post_str = post_content ? std::string(post_content) : "";
        printf("  After:  \"%s\" (length: %zu)\n", post_str.c_str(), post_str.length());
        if (post_content) {
            ystring_destroy((char*)post_content);
        }
        ytransaction_commit(post_txn);
        
        result.deltas_applied++;
    }
    
    // Read final text content
    YTransaction *read_txn = ydoc_read_transaction(doc);
    const char *actual = ytext_string(text, read_txn);
    
    std::string actual_str = actual ? std::string(actual) : "";
    
    printf("  Actual:   \"%s\"\n", actual_str.c_str());
    
    // Compare with expected
    if (actual_str == expected) {
        printf("  ✓ Content matches\n");
        printf("  PASS\n");
        result.passed = true;
    } else {
        printf("  ✗ Content mismatch\n");
        printf("    Expected length: %zu\n", expected.length());
        printf("    Actual length:   %zu\n", actual_str.length());
        
        // Character-by-character comparison
        printf("\n    Character comparison:\n");
        size_t max_len = expected.length() > actual_str.length() ? expected.length() : actual_str.length();
        for (size_t i = 0; i < max_len && i < 50; i++) {  // Limit to 50 chars
            char exp_char = i < expected.length() ? expected[i] : '\0';
            char act_char = i < actual_str.length() ? actual_str[i] : '\0';
            
            if (exp_char != act_char) {
                printf("    [%zu] Expected: '%c' (0x%02X), Got: '%c' (0x%02X) ✗\n", 
                       i, 
                       exp_char ? exp_char : ' ', (unsigned char)exp_char,
                       act_char ? act_char : ' ', (unsigned char)act_char);
            } else {
                printf("    [%zu] '%c' (0x%02X) ✓\n", i, exp_char, (unsigned char)exp_char);
            }
        }
        if (max_len > 50) {
            printf("    ... (%zu more characters)\n", max_len - 50);
        }
        
        printf("  FAIL\n");
        result.error_message = "Content mismatch";
    }
    
    // Cleanup
    if (actual) {
        ystring_destroy((char*)actual);
    }
    ytransaction_commit(read_txn);
    ydoc_destroy(doc);
    
    return result;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <test-directory>\n", argv[0]);
        fprintf(stderr, "Example: %s ../test-data/001-single-insert\n", argv[0]);
        return 1;
    }
    
    const char *test_dir = argv[1];
    
    // Check if directory exists
    struct stat st;
    if (stat(test_dir, &st) != 0 || !S_ISDIR(st.st_mode)) {
        fprintf(stderr, "Error: '%s' is not a valid directory\n", test_dir);
        return 1;
    }
    
    printf("========================================\n");
    printf("CRDT Delta Consumer Test\n");
    printf("========================================\n");
    
    TestResult result = run_test(test_dir);
    
    printf("\n========================================\n");
    if (result.passed) {
        printf("Result: PASS ✓\n");
        printf("Deltas applied: %d/%d\n", 
               result.deltas_applied, 
               result.deltas_applied + result.deltas_failed);
    } else {
        printf("Result: FAIL ✗\n");
        printf("Error: %s\n", result.error_message.c_str());
        printf("Deltas applied: %d\n", result.deltas_applied);
        printf("Deltas failed: %d\n", result.deltas_failed);
    }
    printf("========================================\n");
    
    return result.passed ? 0 : 1;
}

